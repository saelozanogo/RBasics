\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdftitle={caracteres y datos de tiempo},
            pdfauthor={Santiago Lozano},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\title{caracteres y datos de tiempo}
\author{Santiago Lozano}
\date{7 de marzo de 2020}

\begin{document}
\maketitle

\subsection{Texto y caracteres}\label{texto-y-caracteres}

Recordemos que en R los datos de tipo \texttt{character} son definidos
en comillias

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ "abc"}
\NormalTok{b <-}\StringTok{ "123"}
\end{Highlighting}
\end{Shaded}

de igual forma sabemos que los datos de tipo \texttt{numeric} pueden ser
transformados a \texttt{character}, pero los \texttt{character} de tipo
no numérico no pueden ser tranformados a \texttt{numeric}

\begin{verbatim}
as.numeric(a)
\end{verbatim}

\begin{verbatim}
NAs introduced by coercion[1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 123
\end{verbatim}

Debemos tener una distinción entre \texttt{length()} que especifica el
largo de un vector y \texttt{nchar()} el cual despliega el número de
caracteres que tiene un \texttt{character}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mascotas<-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"gato"}\NormalTok{,}\StringTok{"perro"}\NormalTok{,}\StringTok{"conejo"}\NormalTok{,}\StringTok{"hamster"}\NormalTok{)}
\KeywordTok{length}\NormalTok{(mascotas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nchar}\NormalTok{(mascotas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 5 6 7
\end{verbatim}

Y también debemos hacer una distinción entre vectores de tipo
\texttt{character} y \texttt{factor}, los últimos, los cuales establence
una variable de tipo cualitativo

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(mascotas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.factor}\NormalTok{(mascotas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

R tiene preestablecido vectores que tienen las letras del abecedario en
minúscula

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letters}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
\end{verbatim}

Y mayúscula

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LETTERS}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
## [20] "T" "U" "V" "W" "X" "Y" "Z"
\end{verbatim}

Podemos desplegar los datos \texttt{character} si comillas

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{noquote}\NormalTok{(letters)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
\end{verbatim}

Y especificar cuál es la posición de cierto elemento explícito de un
vector

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which}\NormalTok{(letters}\OperatorTok{==}\StringTok{"n"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 14
\end{verbatim}

Concatenación de datos de tipo \texttt{character} usamos distintas
funciones

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(a,b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc" "123"
\end{verbatim}

la cual despliega en un vector que concatena los dos vectores o datos,
otra forma es con

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(a,b,}\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc123"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(a,b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc 123"
\end{verbatim}

Es importante mencionar que cada dato \texttt{character} en una
estructura de datos no pierde su espacio en blanco cuando se le aplica
\texttt{paste()}, y se especifica \texttt{sep=""}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(a,b,}\StringTok{" una frase más larga conteniedo espacios en blanco"}\NormalTok{,}\DataTypeTok{sep=}\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc123 una frase más larga conteniedo espacios en blanco"
\end{verbatim}

Si uno de los argumentos de \texttt{paste()} es un vector, cada uno de
los elementos del vector es es pegado junto con el resto de los
argumentos

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d <-}\StringTok{ }\KeywordTok{c}\NormalTok{(a,b,}\StringTok{"nuevo"}\NormalTok{)}
\NormalTok{e <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(d,}\StringTok{"una frase más larga que contiene espacios en blanco"}\NormalTok{)}
\NormalTok{e}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "abc una frase más larga que contiene espacios en blanco"  
## [2] "123 una frase más larga que contiene espacios en blanco"  
## [3] "nuevo una frase más larga que contiene espacios en blanco"
\end{verbatim}

Si por ejemplo, queremos especificar varios elementos que están en una
carpeta

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{drive <-}\StringTok{ "c:"}
\NormalTok{carpeta <-}\StringTok{ "programcion"}
\NormalTok{archivo <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"archivo1"}\NormalTok{,}\StringTok{"archivo2"}\NormalTok{,}\StringTok{"archivo3"}\NormalTok{)}
\NormalTok{extension <-}\StringTok{ ".txt"}
\KeywordTok{paste}\NormalTok{(drive, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{"}\NormalTok{,carpeta, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{"}\NormalTok{,archivo, extension,}\DataTypeTok{sep=}\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "c:\\programcion\\archivo1.txt" "c:\\programcion\\archivo2.txt"
## [3] "c:\\programcion\\archivo3.txt"
\end{verbatim}

caso de dos vectores

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{string1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{,}\StringTok{"ab"}\NormalTok{,}\StringTok{"B"}\NormalTok{,}\StringTok{"bba"}\NormalTok{,}\StringTok{"one"}\NormalTok{,}\StringTok{"!@"}\NormalTok{,}\StringTok{"brute"}\NormalTok{)}
\NormalTok{string2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"e"}\NormalTok{,}\StringTok{"D"}\NormalTok{)}
\KeywordTok{paste}\NormalTok{(string1,string2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a e"     "ab D"    "B e"     "bba D"   "one e"   "!@ D"    "brute e"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(string1,string2,}\DataTypeTok{sep=}\StringTok{"-"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a-e"     "ab-D"    "B-e"     "bba-D"   "one-e"   "!@-D"    "brute-e"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(string1,string2,}\DataTypeTok{collapse=}\StringTok{""}\NormalTok{,}\DataTypeTok{sep=}\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "aeabDBebbaDonee!@Dbrutee"
\end{verbatim}

donde \texttt{collapse=} es usado para concatenar elementos dentro del
dato \texttt{character}

\subsection{Extracción de partes de un
character}\label{extracciuxf3n-de-partes-de-un-character}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frase <-}\StringTok{ "el rápido gato marrón salta sobre el perro perezoso"}
\end{Highlighting}
\end{Shaded}

la función \texttt{substr()} se usa para extraer letras de un número
especificado de caracteres con un output de \texttt{character}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substr}\NormalTok{(frase,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "e"
\end{verbatim}

Aquí se extrajo una letra desde la primera letra

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substr}\NormalTok{(frase,}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "l r"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{20}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{)\{}
\NormalTok{  q[i] <-}\StringTok{ }\KeywordTok{substr}\NormalTok{(frase,}\DecValTok{1}\NormalTok{,i)}
\NormalTok{\}}
\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "e"                    "el"                   "el "                 
##  [4] "el r"                 "el rá"                "el ráp"              
##  [7] "el rápi"              "el rápid"             "el rápido"           
## [10] "el rápido "           "el rápido g"          "el rápido ga"        
## [13] "el rápido gat"        "el rápido gato"       "el rápido gato "     
## [16] "el rápido gato m"     "el rápido gato ma"    "el rápido gato mar"  
## [19] "el rápido gato marr"  "el rápido gato marró"
\end{verbatim}

\subsection{Separación de Characters}\label{separaciuxf3n-de-characters}

Para separar elementos de un \texttt{character} (incluyendo espacios en
blano) de tipo de dato, usamos \texttt{strsplit()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{strsplit}\NormalTok{(frase,}\DataTypeTok{split =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##  [1] "e" "l" " " "r" "á" "p" "i" "d" "o" " " "g" "a" "t" "o" " " "m" "a" "r" "r"
## [20] "ó" "n" " " "s" "a" "l" "t" "a" " " "s" "o" "b" "r" "e" " " "e" "l" " " "p"
## [39] "e" "r" "r" "o" " " "p" "e" "r" "e" "z" "o" "s" "o"
\end{verbatim}

la función \texttt{table} puede ser usada para contar las ocurrencias de
cada letra

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(}\KeywordTok{strsplit}\NormalTok{(frase,}\DataTypeTok{split =} \StringTok{""}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##   a á b d e g i l m n o ó p r s t z 
## 8 4 1 1 1 6 1 1 3 1 1 6 1 3 7 3 2 1
\end{verbatim}

Para separar por palabras

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{strsplit}\NormalTok{(frase, }\StringTok{" "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "el"       "rápido"   "gato"     "marrón"   "salta"    "sobre"    "el"      
## [8] "perro"    "perezoso"
\end{verbatim}

contando el número de letras de cada palabra

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(}\KeywordTok{strsplit}\NormalTok{(frase, }\StringTok{" "}\NormalTok{), nchar)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 2 6 4 6 5 5 2 5 8
\end{verbatim}

Revertiendo el orden de las letras

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(}\KeywordTok{strsplit}\NormalTok{(frase,}\StringTok{""}\NormalTok{),rev)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##  [1] "o" "s" "o" "z" "e" "r" "e" "p" " " "o" "r" "r" "e" "p" " " "l" "e" " " "e"
## [20] "r" "b" "o" "s" " " "a" "t" "l" "a" "s" " " "n" "ó" "r" "r" "a" "m" " " "o"
## [39] "t" "a" "g" " " "o" "d" "i" "p" "á" "r" " " "l" "e"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(}\KeywordTok{strsplit}\NormalTok{(frase, }\OtherTok{NULL}\NormalTok{), rev), paste, }\DataTypeTok{collapse=}\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "osozerep orrep le erbos atlas nórram otag odipár le"
\end{verbatim}

Para usar una palabra como marca de separación

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{strsplit}\NormalTok{(frase,}\StringTok{"el"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] ""                                 " rápido gato marrón salta sobre "
## [3] " perro perezoso"
\end{verbatim}

Y extrayendo un elemento de esta lista

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{strsplit}\NormalTok{(frase,}\StringTok{"el"}\NormalTok{)[[}\DecValTok{1}\NormalTok{]][}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] " rápido gato marrón salta sobre "
\end{verbatim}

\subsection{Transformación de textos en mayúscula y
minúscula}\label{transformaciuxf3n-de-textos-en-mayuxfascula-y-minuxfascula}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{toupper}\NormalTok{(frase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "EL RÁPIDO GATO MARRÓN SALTA SOBRE EL PERRO PEREZOSO"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tolower}\NormalTok{(frase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "el rápido gato marrón salta sobre el perro perezoso"
\end{verbatim}

\subsection{Función match()}\label{funciuxf3n-match}

Esta función responde la tregunta ¿Dónde los valores en el segundo
vector aparecen en el primer vector

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{primero <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{)}
\NormalTok{segundo <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\KeywordTok{match}\NormalTok{(primero,segundo)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] NA  1 NA NA NA  2  3  3  4  1  1  1  3  3  2
\end{verbatim}

vemos que aquí la forma en cómo trabaja la función, así, ¡Dónde el 5 del
primer vector aparece en el segundo vector?, no aparece, entonces R
despiega NA en el output,¿dónde el 8 del primer vector aparece en el
segundo? aparece en el primero, y el programa despliega 1.

Esta función es muy importante a la hora de clasificación en base de
datos

Por ejemplo, en el campo de la mediciona usted tiene un vector que
contiene las identificaciones anónimas de nueve pacientes

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sujetos <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"G"}\NormalTok{, }\StringTok{"M"}\NormalTok{, }\StringTok{"N"}\NormalTok{, }\StringTok{"S"}\NormalTok{, }\StringTok{"T"}\NormalTok{, }\StringTok{"V"}\NormalTok{, }\StringTok{"Z"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Suponga que usted quiere probar una nueva droga a todos los pacientes en
un vector de pacientes seleccionados

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pacientes.selec<-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"E"}\NormalTok{, }\StringTok{"G"}\NormalTok{, }\StringTok{"S"}\NormalTok{, }\StringTok{"U"}\NormalTok{, }\StringTok{"Z"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Usted quiere buscar estos pacientes en la base de datos general para
obtener algunos datos, así podemos usar \texttt{match()} para buscarlos
en la base de datos

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{match}\NormalTok{(sujetos,pacientes.selec)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA NA  2 NA NA  3 NA NA  5
\end{verbatim}

Queremos obtener esta información sabiendo qué paciente se le da la
droga nueva y cuál la convencional

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q<-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\KeywordTok{length}\NormalTok{(}\KeywordTok{match}\NormalTok{(sujetos,pacientes.selec)))}
\NormalTok{droga <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"nueva"}\NormalTok{ , }\StringTok{"convencional"}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(}\KeywordTok{match}\NormalTok{(sujetos,pacientes.selec)))\{}
  \ControlFlowTok{if}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(}\KeywordTok{match}\NormalTok{(sujetos,pacientes.selec))[i])\{}
\NormalTok{    q[i]<-droga[}\DecValTok{2}\NormalTok{]}
\NormalTok{  \}}\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{    q[i]<-droga[}\DecValTok{1}\NormalTok{]}
\NormalTok{  \}}
\NormalTok{\}}
\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "convencional" "convencional" "nueva"        "convencional" "convencional"
## [6] "nueva"        "convencional" "convencional" "nueva"
\end{verbatim}

\subsection{Identificación de
patrones}\label{identificaciuxf3n-de-patrones}

importemos el siguiente dataframe

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setwd}\NormalTok{(}\StringTok{"C:/Users/santiago/Documents/Progrmación en R/2020-I/PR06-caracteres y datos de tiempo"}\NormalTok{)}
\NormalTok{worldfloras<-}\KeywordTok{read.table}\NormalTok{(}\StringTok{"worldfloras.txt"}\NormalTok{,}\DataTypeTok{header=}\NormalTok{T)}
\KeywordTok{attach}\NormalTok{(worldfloras)}
\KeywordTok{names}\NormalTok{(worldfloras)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Country"    "Latitude"   "Area"       "Population" "Flora"     
## [6] "Endemism"   "Continent"
\end{verbatim}

Existe una forma de encontrar patrones en un vector y apartir de este
poder extraer información del dataframe, esto se realiza mediante la
función \texttt{grep}

en el dataframe tenemos una variable \texttt{Country} que corresponde a
ciertos países, el cual es un tió factor pues está en un dataframe

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(Country)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] Afghanistan Albania     Algeria     Andorra     Angola      Antarctica 
## 161 Levels: Afghanistan Albania Algeria Andorra Angola Antarctica ... Zimbabwe
\end{verbatim}

Para extraer la ubicación de los países que Tienen la letra R

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"R"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  27  34  40 116 118 119 120 152
\end{verbatim}

Con lo que, extrayendo los nombres de los países

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"R"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Central African Republic" "Costa Rica"              
## [3] "Dominican Republic"       "Puerto Rico"             
## [5] "Reunion"                  "Romania"                 
## [7] "Rwanda"                   "USSR"
\end{verbatim}

Si queremos los países que comienzan con R

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"^R"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Reunion" "Romania" "Rwanda"
\end{verbatim}

Para seleccionar los países cuyos nombres son más de una palabra y la
que nos esprimera palabra comienza con R

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{" R"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Central African Republic" "Costa Rica"              
## [3] "Dominican Republic"       "Puerto Rico"
\end{verbatim}

Para encontrar los países con dos o más palabras

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(}\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{" "}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Balearic Islands"         "Burkina Faso"            
## [3] "Central African Republic" "Costa Rica"              
## [5] "Dominican Republic"       "El Salvador"
\end{verbatim}

Los países cuyo nombre finaliza en y, usamos \$

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"y$"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hungary"  "Italy"    "Norway"   "Paraguay" "Sicily"   "Turkey"   "Uruguay"
\end{verbatim}

Para condiciones que impliquen expresiones en grupo, es decir, un serie
de números o letras ubicadas alfabéticamente, usamos ``{[}{]}'' dentro
de los cuales indicamos el rango de valores o letras que son
seleccionados. Entonces, para seleccionar los países cuyo nombre
contiene las letras de C a E mayúsculas hacemos

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(}\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"[C-E]"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Cameroon"                 "Canada"                  
## [3] "Central African Republic" "Chad"                    
## [5] "Chile"                    "China"
\end{verbatim}

Aquí hay países como Ivory Coast o Trinstan Cunha que contienen la letra
pero no es la primera, para estos propósitos usamos

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(}\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"^[C-E]"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Cameroon"                 "Canada"                  
## [3] "Central African Republic" "Chad"                    
## [5] "Chile"                    "China"
\end{verbatim}

Para mencionar los países que no cumplen cierta condición usamo el menos
``-'' , así, buscamos los países cuta palabra no finaliza en una letra
de la a la t

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\OperatorTok{-}\KeywordTok{grep}\NormalTok{(}\StringTok{"[a-t]$"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Hungary"  "Italy"    "Norway"   "Paraguay" "Peru"     "Sicily"  
##  [7] "Turkey"   "Uruguay"  "USA"      "USSR"     "Vanuatu"
\end{verbatim}

Si queremos del output anterior quitar USA y USSR podemos poner varias
condiciones

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\OperatorTok{-}\KeywordTok{grep}\NormalTok{(}\StringTok{"[A-T a-t]$"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hungary"  "Italy"    "Norway"   "Paraguay" "Peru"     "Sicily"   "Turkey"  
## [8] "Uruguay"  "Vanuatu"
\end{verbatim}

El punto en R es un símbolo que es considerado para condicionar
cualquier caracter, así, por ejemplo, si queremos especificar la palabra
cuya letra es ``y'' hacemos \^{}.y, es decir comenzando con cualquier
palabra que la siguiente sea ``y''

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"^.y"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Cyprus" "Syria"
\end{verbatim}

para los países con y como segunda letra \^{}..y

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"^..y"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Egypt"      "Guyana"     "Seychelles"
\end{verbatim}

Si queremos que y sea la sexta letra

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"^.\{5\}y"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Norway" "Sicily" "Turkey"
\end{verbatim}

entonces el \(.\{5\}\) menciona 5 caracteres cualesquiera,

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"^.\{,4\}y"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Cyprus"      "Egypt"       "Guyana"      "Italy"       "Ivory Coast"
##  [6] "Kenya"       "Libya"       "Malaysia"    "Norway"      "Seychelles" 
## [11] "Sicily"      "Syria"       "Turkey"
\end{verbatim}

vemos que ``.'' significa cualquier caracter, mientras que \(\{,4\}\)
significa repetir hasta 4 cualquier cosa antes del \$ (el string final).
Así, todos los países con 15 o más caracteres los filtramos mediante

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.vector}\NormalTok{(Country[}\KeywordTok{grep}\NormalTok{(}\StringTok{"^.\{15,\}$"}\NormalTok{,}\KeywordTok{as.character}\NormalTok{(Country))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Balearic Islands"         "Central African Republic"
## [3] "Dominican Republic"       "Papua New Guinea"        
## [5] "Solomon Islands"          "Trinidad & Tobago"       
## [7] "Tristan da Cunha"
\end{verbatim}

\subsection{Subtitucion de text en un
character}\label{subtitucion-de-text-en-un-character}

R tiene la posibilidad de buscar un caracter y realizar una operación
que reemplace ese caracter mediante las funciones \texttt{sub()} y
\texttt{gsub()}, funciones las cuales difieren sólo en que
\texttt{sub()} reemplaza sólo la primera ocurrencia y \texttt{gsub()}
reemplaza todas las ocurrencias, veamos un ejemplo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"arm"}\NormalTok{, }\StringTok{"leg"}\NormalTok{, }\StringTok{"head"}\NormalTok{, }\StringTok{"foot"}\NormalTok{, }\StringTok{"hand"}\NormalTok{, }\StringTok{"hindleg"}\NormalTok{, }\StringTok{"elbow"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

y queremos reemplazar ``h'' por ``H''

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gsub}\NormalTok{(}\StringTok{"h"}\NormalTok{,}\StringTok{"H"}\NormalTok{,text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "arm"     "leg"     "Head"    "foot"    "Hand"    "Hindleg" "elbow"
\end{verbatim}

Si queremos sólo reemplazar la primera ocurrencia

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sub}\NormalTok{(}\StringTok{"o"}\NormalTok{,}\StringTok{"O"}\NormalTok{,text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "arm"     "leg"     "head"    "fOot"    "hand"    "hindleg" "elbOw"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gsub}\NormalTok{(}\StringTok{"^."}\NormalTok{,}\StringTok{"O"}\NormalTok{,text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Orm"     "Oeg"     "Oead"    "Ooot"    "Oand"    "Oindleg" "Olbow"
\end{verbatim}

Para este dividimos en 2 grupos, en primer grupo al mencionar
\texttt{\textbackslash{}\textbackslash{}w} los caracteres que son letras
despues \texttt{?} completantdo con frecuencia una vez, es decir,
\texttt{(\textbackslash{}\textbackslash{}w?)} me agrupa un grupo de la
primera letra y el segundo al poner \texttt{\textbackslash{}*} agregar
al menos un item, es decir, \texttt{\textbackslash{}\textbackslash{}w*}
la cadena de al menos cero letras

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gsub}\NormalTok{(}\StringTok{"(}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{w?)(}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{w*)"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{U}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{1}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{L}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{2"}\NormalTok{,text, }\DataTypeTok{perl=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Arm"     "Leg"     "Head"    "Foot"    "Hand"    "Hindleg" "Elbow"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gsub}\NormalTok{(}\StringTok{"(}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{w*)"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{U}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{1"}\NormalTok{,text, }\DataTypeTok{perl=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ARM"     "LEG"     "HEAD"    "FOOT"    "HAND"    "HINDLEG" "ELBOW"
\end{verbatim}

\subsection{Localización de un patrón en un vector usando
regexpr}\label{localizaciuxf3n-de-un-patruxf3n-en-un-vector-usando-regexpr}

En vez de sustituir el patrón, podemos querer saber si este ocurren en
un string, y si es así, donde ocurre dentro de cada string. El resultado
de \texttt{regexpr} es por tanto un vector numeric, pero indicando la
posición de la primera instancia del patrón en el string. Si el patrón
no aparece en el string, el valor por defecto retornado por
\texttt{regexpr} es \texttt{-1}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "arm"     "leg"     "head"    "foot"    "hand"    "hindleg" "elbow"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{regexpr}\NormalTok{(}\StringTok{"o"}\NormalTok{,text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -1 -1 -1  2 -1 -1  4
## attr(,"match.length")
## [1] -1 -1 -1  1 -1 -1  1
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
\end{verbatim}

Podemos indicar que despliegue cero si el string no aparece en y un
número dependiento la posición de la primera ocurrencia del string

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gregexpr}\NormalTok{(}\StringTok{"o"}\NormalTok{,text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
## 
## [[4]]
## [1] 2 3
## attr(,"match.length")
## [1] 1 1
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
## 
## [[5]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
## 
## [[6]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
## 
## [[7]]
## [1] 4
## attr(,"match.length")
## [1] 1
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
\end{verbatim}

Desplegando una lista donde cada elemento de la lista es un vector el
cual, el primer elemento despliega las posiciones de las ocurrencias del
patrón, el segundo el largo del texto encontrado, el tercero el tipo de
dato y el cuarto su usa bytes

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(}\KeywordTok{gregexpr}\NormalTok{(}\StringTok{"o"}\NormalTok{,text),length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1
## 
## [[3]]
## [1] 1
## 
## [[4]]
## [1] 2
## 
## [[5]]
## [1] 1
## 
## [[6]]
## [1] 1
## 
## [[7]]
## [1] 1
\end{verbatim}

el cual genera el número de ocurrencias del patrón

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{freq <-}\StringTok{ }\KeywordTok{as.vector}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(}\KeywordTok{gregexpr}\NormalTok{(}\StringTok{"o"}\NormalTok{,text),length)))}
\NormalTok{present <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{regexpr}\NormalTok{(}\StringTok{"o"}\NormalTok{,text)}\OperatorTok{<}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{freq}\OperatorTok{*}\NormalTok{present}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 0 0 2 0 0 1
\end{verbatim}

Indicando cero si no hay match y un número distinto de cero indicando la
cantidad de ocurrencias del patrón

La función \texttt{charmatch} es para realizar match entre caracteres,
buscando si el patrón se encuentran en alguna parte del elemento del
vector, y despliega cero si hay múltiple matches

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{charmatch}\NormalTok{(}\StringTok{"m"}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\StringTok{"median"}\NormalTok{, }\StringTok{"mode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{charmatch}\NormalTok{(}\StringTok{"med"}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\StringTok{"median"}\NormalTok{, }\StringTok{"mode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\subsection{Uso de \%in\% y which}\label{uso-de-in-y-which}

Si queremos ver matches entre vectores de caracteres

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stock <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"carro"}\NormalTok{,}\StringTok{"van"}\NormalTok{)}
\NormalTok{requisitos <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"camión","}\NormalTok{remolque}\StringTok{","}\NormalTok{van}\StringTok{","}\NormalTok{deportivo}\StringTok{","}\NormalTok{carro}\StringTok{","}\NormalTok{vagón",}\StringTok{"carro"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Usamos \texttt{which} si queremos encontrar la ubicación del primer
vector nombrado en cualesquieras de las entradas del segundo vector
nombrado

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which}\NormalTok{(requisitos }\OperatorTok{%in%}\StringTok{ }\NormalTok{stock)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 5 7
\end{verbatim}

Si queremos saber que elementos son

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{requisitos[}\KeywordTok{which}\NormalTok{(requisitos }\OperatorTok{%in%}\StringTok{ }\NormalTok{stock)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "van"   "carro" "carro"
\end{verbatim}

y para saber la ubicación exacta

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(requisitos, }\StringTok{"%in%"}\NormalTok{, stock)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    camión  remolque       van deportivo     carro     vagón     carro 
##     FALSE     FALSE      TRUE     FALSE      TRUE     FALSE      TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{requisitos }\OperatorTok{%in%}\StringTok{ }\NormalTok{stock}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(requisitos, }\StringTok{"%in%"}\NormalTok{, stock))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   van carro carro 
##     3     5     7
\end{verbatim}

\subsection{Más datos sobre búsqueda de
patrones}\label{muxe1s-datos-sobre-buxfasqueda-de-patrones}

Para nuestros propósitos de especificar estos patrones, ciertos
caracteres son llamados \textbf{metacaracteres}, especificamente
\texttt{\textbackslash{}\ \textbar{}\ (\ )\ {[}\ {]}\ \{\ \}\ \^{}\ \$\ *\ +\ ?},
así cualquier metacaracter con significado especial en nuestro string
puede ser citado precediéndolo con un backslash
\texttt{\textbackslash{}\textbackslash{}}, es decir si quiero el
significado literal de \texttt{\{} usamos \texttt{\textbackslash{}\{}.

Existen varias tipos de sintaxis par ala búsqueda de patrones, sin
embargo, en R, las expresiones regulares son especificadas por
\textbf{POSIX (POrtable Operating System Interface} 1003.2, ya sea
extendido o básico, dependiendo sobre el valor del argumento extendido,
a menos que \texttt{perl=TRUE}, lo que corresponde a que usaremos las
expresiones regulares tipo PCRE (Perl Compatible Regular Expresions)

Observe que las llaves cuadradas {[}{]} son parte de los nombres
simbólicos y deben ser incluídos en adición a las llave, por ejemplo
{[}{[}:alnum:{]}{]} significa {[}0-9A-Za-z{]}, algunas interpretaciones
de POSIX las vemos en el documento adjunto, por ejemplo
\texttt{\textbackslash{}\{n\textbackslash{}\}} queiere decir el patrón
es buscado n o más veces,
\texttt{\textbackslash{}\{,m\textbackslash{}\}} el patrón es buscado
hasta m veces, \texttt{\textbackslash{}\{m,n\}\textbackslash{}} el
patrón es buscado entre n y m veces

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"arm"}\NormalTok{,}\StringTok{"leg"}\NormalTok{,}\StringTok{"head"}\NormalTok{, }\StringTok{"foot"}\NormalTok{,}\StringTok{"hand"}\NormalTok{, }\StringTok{"hindleg"}\NormalTok{, }\StringTok{"elbow"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"o\{1\}"}\NormalTok{,text,}\DataTypeTok{value=}\NormalTok{T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "foot"  "elbow"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"o\{2\}"}\NormalTok{,text,}\DataTypeTok{value=}\NormalTok{T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "foot"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"o\{3\}"}\NormalTok{,text,}\DataTypeTok{value=}\NormalTok{T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## character(0)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"[[:alnum:]]\{4, \}"}\NormalTok{,text,}\DataTypeTok{value=}\NormalTok{T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "head"    "foot"    "hand"    "hindleg" "elbow"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"[[:alnum:]]\{5, \}"}\NormalTok{,text,}\DataTypeTok{value=}\NormalTok{T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "hindleg" "elbow"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"[[:alnum:]]\{6, \}"}\NormalTok{,text,}\DataTypeTok{value=}\NormalTok{T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "hindleg"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"[[:alnum:]]\{7, \}"}\NormalTok{,text,}\DataTypeTok{value=}\NormalTok{T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "hindleg"
\end{verbatim}

\subsection{Eliminar texto estampado en cadenas
complejas}\label{eliminar-texto-estampado-en-cadenas-complejas}

Suponga que queremos separar la información en estas cadenas complicadas

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{entradas <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Prueba 1 58 cervoconis (52 coincidencias)"}\NormalTok{,}\StringTok{"Prueba 2 60 terrestris (51 conincidencias)"}\NormalTok{,}\StringTok{"Prueba 8 109 flavicollis (101 coincidencias)"}\NormalTok{)}
\NormalTok{entradas}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Prueba 1 58 cervoconis (52 coincidencias)"   
## [2] "Prueba 2 60 terrestris (51 conincidencias)"  
## [3] "Prueba 8 109 flavicollis (101 coincidencias)"
\end{verbatim}

la primera tarea es remover el material del número de coincidencias

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gsub}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{(.*}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{)$"}\NormalTok{, }\StringTok{""}\NormalTok{, entradas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Prueba 1 58 cervoconis "   "Prueba 2 60 terrestris "  
## [3] "Prueba 8 109 flavicollis "
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gsub}\NormalTok{(}\StringTok{" *$"}\NormalTok{, }\StringTok{""}\NormalTok{,}\KeywordTok{gsub}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{(.*}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{)$"}\NormalTok{, }\StringTok{""}\NormalTok{, entradas))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Prueba 1 58 cervoconis"   "Prueba 2 60 terrestris"  
## [3] "Prueba 8 109 flavicollis"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pos <-}\StringTok{ }\KeywordTok{regexpr}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{(.*}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{)$"}\NormalTok{, entradas)}
\NormalTok{pos}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 24 24 26
## attr(,"match.length")
## [1] 18 19 19
## attr(,"index.type")
## [1] "chars"
## attr(,"useBytes")
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substring}\NormalTok{(entradas, }\DataTypeTok{first=}\NormalTok{pos}\OperatorTok{+}\DecValTok{1}\NormalTok{, }\DataTypeTok{last=}\NormalTok{pos}\OperatorTok{+}\KeywordTok{attr}\NormalTok{(pos,}\StringTok{"match.length"}\NormalTok{)}\OperatorTok{-}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "52 coincidencias"  "51 conincidencias" "101 coincidencias"
\end{verbatim}

\subsection{Fechas y tiempos en R}\label{fechas-y-tiempos-en-r}

El manejo de datos se vuelve altamente complejo dado la variabilidad que
tiene este, veamos como R posee un sistema robusto que trata con esta
complejidad. Para ver como R maneja fechas y horas, echemos una mirada
en

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Sys.time}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2020-05-02 14:16:27 -05"
\end{verbatim}

cabe aclarar que la zona horaria e despliega en string, esta
represetación de la fecha y hora como un caracter es bastante amigable
pero no es buena para cálculo, con lo que necesitamos una expresión
numérica para combinar fechas y horas. La convención que R utiliza está
basada en segundos. Usted puede siempre agregar hasta días o años, pero
no puede hacer lo contrario. La línea de base para expresar la fecha y
hora de hoy en segundos es el 1 de enero de 1970:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1588446988
\end{verbatim}

Esto está bien para graficar series de tiempo, pero no para calcular que
mes corresponde o qué día. Para responder estas cuestiones podemos
acceder al tablero de variables categoricas asociadas con la fecha. Para
acomodar esto R, usa el sistema POSIX para representar tiempos y fechas

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "POSIXct" "POSIXt"
\end{verbatim}

Podemos pensar en la clase POSIXct con el sufijo ct continuo en el
tienmpo y POSIXlt con el sufijo lista de tiempo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{time.list <-}\StringTok{ }\KeywordTok{as.POSIXlt}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{())}
\KeywordTok{unlist}\NormalTok{(time.list)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                sec                min               hour               mday 
## "27.9386761188507"               "16"               "14"                "2" 
##                mon               year               wday               yday 
##                "4"              "120"                "6"              "122" 
##              isdst               zone             gmtoff 
##                "0"              "-05"           "-18000"
\end{verbatim}

Aquí la hora está en formato militar, el mes con el correpondiente
número mday es el día del mes, wday es el día de la semana con domingo=0
a sábado=6, el día del año con yday, year es el año teniendo en cuenta
0=1900 e isdst es una variable lógica si está en horario de verano

\subsection{Leyendo tiempos de un
archivo}\label{leyendo-tiempos-de-un-archivo}

Es muy probable que sus datos estén en formato Excel, por ejemplo
03/09/2014, donde día/mes/año, así

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setwd}\NormalTok{(}\StringTok{"~/Progrmación en R/2020-I/PR06-caracteres y datos de tiempo"}\NormalTok{)}
\NormalTok{data <-}\StringTok{ }\KeywordTok{read.table}\NormalTok{(}\StringTok{"dates.txt"}\NormalTok{,}\DataTypeTok{header=}\NormalTok{T)}
\KeywordTok{attach}\NormalTok{(data)}
\NormalTok{data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   x       date
## 1 3 15/06/2014
## 2 1 16/06/2014
## 3 6 17/06/2014
## 4 7 18/06/2014
## 5 8 19/06/2014
## 6 9 20/06/2014
\end{verbatim}

cuando se usa \texttt{read.table()} este por defecto toma los valore de
fecha y los convierte de tipo \texttt{factor}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mode}\NormalTok{(date)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(date)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "factor"
\end{verbatim}

El punto es que para nuestros porpósitos, R de inicio no reconoce las
fechas como tipo \texttt{date}. para esto empleamos la función
\texttt{strptime}

Para esta función proveemos un formato establecido en comillas en el que
le decimos a R que esperar exactamente, en qué orden y separado bajo qué
símbolos. Para este ejemplo tenemos días (en 2 dígitos), meses y años,
separados por slashes

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Rdate <-}\StringTok{ }\KeywordTok{strptime}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(date),}\StringTok{"%d/%m/%Y"}\NormalTok{)}
\NormalTok{Rdate}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2014-06-15 -05" "2014-06-16 -05" "2014-06-17 -05" "2014-06-18 -05"
## [5] "2014-06-19 -05" "2014-06-20 -05"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(Rdate)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "POSIXlt" "POSIXt"
\end{verbatim}

Con lo que simepre es buena idea poner los datos en el data frame

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(data,Rdate)}
\NormalTok{data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   x       date      Rdate
## 1 3 15/06/2014 2014-06-15
## 2 1 16/06/2014 2014-06-16
## 3 6 17/06/2014 2014-06-17
## 4 7 18/06/2014 2014-06-18
## 5 8 19/06/2014 2014-06-19
## 6 9 20/06/2014 2014-06-20
\end{verbatim}

Con estos datos podemos hacer cálculos para saber por ejemplo el valor
medio de x de cada día de la semana

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tapply}\NormalTok{(x,Rdate}\OperatorTok{$}\NormalTok{wday,mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0 1 2 3 4 5 
## 3 1 6 7 8 9
\end{verbatim}

así la menor media es los lunes y la mayor los viernes, es comlicado
recordar los formatos de strptime, equí los recordamos

poner la imagen

Existe una función útil que nos despliega el nombre de la semana

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{strptime}\NormalTok{(}\StringTok{"01/02/2014"}\NormalTok{,}\DataTypeTok{format=}\StringTok{"%d/%m/%Y"}\NormalTok{)}
\KeywordTok{weekdays}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "sábado"
\end{verbatim}

el cual fue convertido de

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y}\OperatorTok{$}\NormalTok{wday}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

Otro tipo de fecha, tiene que ver con los años en 2 dígitos
(\texttt{\%y}), y los meses abreviados (\texttt{\%b}) si usar
separadores

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{other.dates <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"1ene.99"}\NormalTok{, }\StringTok{"2ene.05"}\NormalTok{, }\StringTok{"31mar.04"}\NormalTok{, }\StringTok{"30jul.05"}\NormalTok{)}
\KeywordTok{strptime}\NormalTok{(other.dates, }\StringTok{"%d%b%y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1999-01-01 -05" "2005-01-02 -05" "2004-03-31 -05" "2005-07-30 -05"
\end{verbatim}

Aquí otra posibilidad con el año, mes con el nombre completo y, seguido
de la semana del año, y el día de la semana abreviadas

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yet.another.date <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"2016 enero 2 lun."}\NormalTok{,}\StringTok{"2017 febrero 6 vie."}\NormalTok{,}\StringTok{"2018}
\StringTok{marzo 10 jue."}\NormalTok{)}
\KeywordTok{strptime}\NormalTok{(yet.another.date,}\StringTok{"%Y %B %W %a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2016-01-11 -05" "2017-02-10 -05" "2018-03-08 -05"
\end{verbatim}

el sistema es inteligente en saber la fecha del lunes en la semana
número 2 de enero de 2016

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yet.more.dates <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"2016 2 lun."}\NormalTok{,}\StringTok{"2017 6 vie."}\NormalTok{,}\StringTok{"2018 10 jue."}\NormalTok{)}
\KeywordTok{strptime}\NormalTok{(yet.more.dates,}\StringTok{"%Y %W %a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2016-01-11 -05" "2017-02-10 -05" "2018-03-08 -05"
\end{verbatim}

\subsection{Función difftime}\label{funciuxf3n-difftime}

La función \texttt{difftime} la diferencia entre 2 objetos de fechas en
el tiempo y retorna un objeto de clase \texttt{difftime} con un atributo
indicando la unidad, se puede usar varias operaciones aritméticas sobre
\texttt{difftime} como
\texttt{round},\texttt{signif},\texttt{floor},\texttt{ceiling},\texttt{trunc},\texttt{abs},\texttt{sign}
y ciertos operadores lógicos. Podemos crear un objeto \texttt{difftime}
de la siguiente manera

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yet.more.dates <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"2016 2 lun."}\NormalTok{,}\StringTok{"2017 6 vie."}\NormalTok{,}\StringTok{"2018 10 jue."}\NormalTok{)}
\KeywordTok{as.difftime}\NormalTok{(yet.more.dates,}\StringTok{"%Y %W %a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time differences in days
## [1] -1573 -1177  -786
\end{verbatim}

o

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{difftime}\NormalTok{(}\StringTok{"2014-02-06"}\NormalTok{,}\StringTok{"2014-07-06"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time difference of -150 days
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{round}\NormalTok{(}\KeywordTok{difftime}\NormalTok{(}\StringTok{"2014-02-06"}\NormalTok{,}\StringTok{"2014-07-06"}\NormalTok{),}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time difference of -150 days
\end{verbatim}

\subsection{Cálculos con fechas y
tiempo}\label{cuxe1lculos-con-fechas-y-tiempo}

Usted puede hacer las siguientes operaciones con fechas y tiempos

\begin{itemize}
\item
  tiempo + número
\item
  tiempo - número
\item
  tiempo1 - tiempo2
\item
  tiempo1 operación lógica tiempo2
\end{itemize}

donde los operadores lógicos son
\texttt{==},\texttt{!=},\texttt{\textless{}},\texttt{\textless{}=},\texttt{\textgreater{}}
o \texttt{\textgreater{}=} usted puede agragar o sustraer un número de
segundos o un objeto \texttt{difftime} desde un objeto de fecha-tiempo,
pero no puede agregar dos objetos fecha-tiempo. LA sustracción de dos
objetos fecha-tiempo es equivalente a usar \texttt{difftime}. A menos
que la zona horario haya sido especificada,los objetos tipo
\texttt{POSIXlt} son interpetados estando en la zona horaria actual en
los cálculo

Lo que debe comprender es que debe convertir sus fechas y horas en
objetos POSIXlt antes de comenzar a hacer cualquier cálculo. Una vez que
son objetos POSIXlt, es sencillo calcular medias, diferencias, etc. Aquí
queremos calcular el número de días entre dos fechas, 22 de octubre de
2015 y 22 de octubre de 2018:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y2 <-}\StringTok{ }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-10-22"}\NormalTok{)}
\NormalTok{y1 <-}\StringTok{ }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2018-10-22"}\NormalTok{)}
\NormalTok{y1}\OperatorTok{-}\NormalTok{y2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time difference of 1096 days
\end{verbatim}

\subsection{Las funciones difftime y
as.difftime}\label{las-funciones-difftime-y-as.difftime}

Resolver la diferencia horaria entre dos fechas y horas involucra la
función \texttt{difftime}, que toma dos objetos de fecha y hora como
argumentos. La función devuelve un objeto de clase \texttt{difftime} con
un atributo que indica las unidades. Por ejemplo, ¿cuántos días
transcurrieron entre el 15 de agosto de 2013 y el 21 de octubre de 2015?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{difftime}\NormalTok{(}\StringTok{"2015-10-21"}\NormalTok{,}\StringTok{"2013-8-15"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time difference of 797 days
\end{verbatim}

si usted quiere el número de días para usar en el cálculo

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{difftime}\NormalTok{(}\StringTok{"2015-10-21"}\NormalTok{,}\StringTok{"2013-8-15"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 797
\end{verbatim}

Su usted tiene tiempo pero no fechas, entonces usted puede usar la
función \texttt{as.difftime} para crear objetos apropiados para los
cálculos

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 <-}\StringTok{ }\KeywordTok{as.difftime}\NormalTok{(}\StringTok{"6:14:21"}\NormalTok{)}
\NormalTok{t2 <-}\StringTok{ }\KeywordTok{as.difftime}\NormalTok{(}\StringTok{"5:12:32"}\NormalTok{)}
\NormalTok{t1}\OperatorTok{-}\NormalTok{t2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time difference of 1.030278 hours
\end{verbatim}

A menudo querrá crear objetos POSIXlt a partir de componentes
almacenados en diferentes vectores dentro de un dataframe. Por ejemplo,
aquí hay un dataframe con las horas, minutos y segundos de un
experimento con dos niveles de factores en cuatro columnas separadas:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setwd}\NormalTok{(}\StringTok{"~/Progrmación en R/2020-I/PR06-caracteres y datos de tiempo"}\NormalTok{)}
\NormalTok{times <-}\StringTok{ }\KeywordTok{read.table}\NormalTok{(}\StringTok{"times.txt"}\NormalTok{,}\DataTypeTok{header=}\NormalTok{T)}
\KeywordTok{attach}\NormalTok{(times)}
\NormalTok{times}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    hrs min sec experiment
## 1    2  23   6          A
## 2    3  16  17          A
## 3    3   2  56          A
## 4    2  45   0          A
## 5    3   4  42          A
## 6    2  56  25          A
## 7    3  12  28          A
## 8    1  57  12          A
## 9    2  22  22          B
## 10   1  42   7          B
## 11   2  31  17          B
## 12   3  15  16          B
## 13   2  28   4          B
## 14   1  55  34          B
## 15   2  17   7          B
## 16   1  48  48          B
\end{verbatim}

Peguemos los valores dado que los tiempo no están en formato POSIXlt

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(hrs,min,sec,}\DataTypeTok{sep=}\StringTok{":"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2:23:6"  "3:16:17" "3:2:56"  "2:45:0"  "3:4:42"  "2:56:25" "3:12:28"
##  [8] "1:57:12" "2:22:22" "1:42:7"  "2:31:17" "3:15:16" "2:28:4"  "1:55:34"
## [15] "2:17:7"  "1:48:48"
\end{verbatim}

ahora guardemos las diferencias en un vector de \texttt{difftime}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{duracion <-}\StringTok{ }\KeywordTok{as.difftime}\NormalTok{ (}\KeywordTok{paste}\NormalTok{(hrs,min,sec,}\DataTypeTok{sep=}\StringTok{":"}\NormalTok{))}
\NormalTok{duracion}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time differences in hours
##  [1] 2.385000 3.271389 3.048889 2.750000 3.078333 2.940278 3.207778 1.953333
##  [9] 2.372778 1.701944 2.521389 3.254444 2.467778 1.926111 2.285278 1.813333
\end{verbatim}

llevemos a cabo nuestros cálculos como media varianza usando
\texttt{tapply}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tapply}\NormalTok{(duracion,experiment,mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        A        B 
## 2.829375 2.292882
\end{verbatim}

cuya respuesta está en horas decimales

\subsection{Generacción de secuencias en el
tiempo}\label{generacciuxf3n-de-secuencias-en-el-tiempo}

Podemos generar secuencias de fechas por años, meses, semanas días del
mes o días de la semana, veamos nuestro primer ejemplo incrementando en
un día

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-04"}\NormalTok{), }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-15"}\NormalTok{), }\StringTok{"1 day"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2015-11-04 -05" "2015-11-05 -05" "2015-11-06 -05" "2015-11-07 -05"
##  [5] "2015-11-08 -05" "2015-11-09 -05" "2015-11-10 -05" "2015-11-11 -05"
##  [9] "2015-11-12 -05" "2015-11-13 -05" "2015-11-14 -05" "2015-11-15 -05"
\end{verbatim}

incrementando en 2 semanas

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-04"}\NormalTok{), }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2016-04-05"}\NormalTok{), }\StringTok{"2 weeks"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2015-11-04 -05" "2015-11-18 -05" "2015-12-02 -05" "2015-12-16 -05"
##  [5] "2015-12-30 -05" "2016-01-13 -05" "2016-01-27 -05" "2016-02-10 -05"
##  [9] "2016-02-24 -05" "2016-03-09 -05" "2016-03-23 -05"
\end{verbatim}

en incrementos de 3 meses

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-04"}\NormalTok{), }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2018-10-04"}\NormalTok{), }\StringTok{"3 months"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2015-11-04 -05" "2016-02-04 -05" "2016-05-04 -05" "2016-08-04 -05"
##  [5] "2016-11-04 -05" "2017-02-04 -05" "2017-05-04 -05" "2017-08-04 -05"
##  [9] "2017-11-04 -05" "2018-02-04 -05" "2018-05-04 -05" "2018-08-04 -05"
\end{verbatim}

con incremento de un año

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-04"}\NormalTok{), }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2026-02-04"}\NormalTok{), }\StringTok{"year"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2015-11-04 -05" "2016-11-04 -05" "2017-11-04 -05" "2018-11-04 -05"
##  [5] "2019-11-04 -05" "2020-11-04 -05" "2021-11-04 -05" "2022-11-04 -05"
##  [9] "2023-11-04 -05" "2024-11-04 -05" "2025-11-04 -05"
\end{verbatim}

Si especifica un número, en lugar de una cadena de caracteres
reconocida, en la parte de la función de secuencia, entonces se supone
que el número es un número de segundos, por lo que esto genera la hora y
la fecha:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-04"}\NormalTok{), }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-05"}\NormalTok{), }\DecValTok{8955}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2015-11-04 00:00:00 -05" "2015-11-04 02:29:15 -05"
##  [3] "2015-11-04 04:58:30 -05" "2015-11-04 07:27:45 -05"
##  [5] "2015-11-04 09:57:00 -05" "2015-11-04 12:26:15 -05"
##  [7] "2015-11-04 14:55:30 -05" "2015-11-04 17:24:45 -05"
##  [9] "2015-11-04 19:54:00 -05" "2015-11-04 22:23:15 -05"
\end{verbatim}

Al igual que con otras formas de seq, puede especificar la longitud del
vector que se generará, en lugar de especificar la fecha final:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-04"}\NormalTok{), }\DataTypeTok{by=}\StringTok{"month"}\NormalTok{, }\DataTypeTok{length=}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2015-11-04 -05" "2015-12-04 -05" "2016-01-04 -05" "2016-02-04 -05"
##  [5] "2016-03-04 -05" "2016-04-04 -05" "2016-05-04 -05" "2016-06-04 -05"
##  [9] "2016-07-04 -05" "2016-08-04 -05"
\end{verbatim}

o puede generar un vector de fechas para que coincida con la longitud de
un vector existente, utilizando \texttt{along\ =} en lugar de
\texttt{length\ =}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{16}\NormalTok{)}
\KeywordTok{seq}\NormalTok{(}\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-04"}\NormalTok{), }\DataTypeTok{by=}\StringTok{"month"}\NormalTok{, }\DataTypeTok{along=}\NormalTok{results )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2015-11-04 -05" "2015-12-04 -05" "2016-01-04 -05" "2016-02-04 -05"
##  [5] "2016-03-04 -05" "2016-04-04 -05" "2016-05-04 -05" "2016-06-04 -05"
##  [9] "2016-07-04 -05" "2016-08-04 -05" "2016-09-04 -05" "2016-10-04 -05"
## [13] "2016-11-04 -05" "2016-12-04 -05" "2017-01-04 -05" "2017-02-04 -05"
\end{verbatim}

Usted puede usar \texttt{weekdays} para extraer los días de la semana de
una serie de datos

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{weekdays}\NormalTok{(}\KeywordTok{seq}\NormalTok{(}\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2015-11-04"}\NormalTok{), }\DataTypeTok{by=}\StringTok{"month"}\NormalTok{, }\DataTypeTok{along=}\NormalTok{results ))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "miércoles" "viernes"   "lunes"     "jueves"    "viernes"   "lunes"    
##  [7] "miércoles" "sábado"    "lunes"     "jueves"    "domingo"   "martes"   
## [13] "viernes"   "domingo"   "miércoles" "sábado"
\end{verbatim}

Suponga que desea encontrar las fechas de todos los lunes en una
secuencia de fechas. Esto implica el uso de subíndices lógicos. Se
seleccionarán los subíndices que evalúen como VERDADERO, por lo que la
declaración lógica que debe realizar es \texttt{wday\ ==\ 1}. (porque el
domingo es \texttt{wday\ ==\ 0}). Cree un objeto llamado \texttt{y} que
contenga los primeros 100 días en 2016 (tenga en cuenta que la fecha de
inicio es el 31 de diciembre de 2015), luego convierta este vector de
fechas en un objeto POSIXlt, una lista llamada \texttt{x}, como esta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{,}\DataTypeTok{origin=}\StringTok{"2015-12-31"}\NormalTok{)}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1] "2016-01-01" "2016-01-02" "2016-01-03" "2016-01-04" "2016-01-05"
##   [6] "2016-01-06" "2016-01-07" "2016-01-08" "2016-01-09" "2016-01-10"
##  [11] "2016-01-11" "2016-01-12" "2016-01-13" "2016-01-14" "2016-01-15"
##  [16] "2016-01-16" "2016-01-17" "2016-01-18" "2016-01-19" "2016-01-20"
##  [21] "2016-01-21" "2016-01-22" "2016-01-23" "2016-01-24" "2016-01-25"
##  [26] "2016-01-26" "2016-01-27" "2016-01-28" "2016-01-29" "2016-01-30"
##  [31] "2016-01-31" "2016-02-01" "2016-02-02" "2016-02-03" "2016-02-04"
##  [36] "2016-02-05" "2016-02-06" "2016-02-07" "2016-02-08" "2016-02-09"
##  [41] "2016-02-10" "2016-02-11" "2016-02-12" "2016-02-13" "2016-02-14"
##  [46] "2016-02-15" "2016-02-16" "2016-02-17" "2016-02-18" "2016-02-19"
##  [51] "2016-02-20" "2016-02-21" "2016-02-22" "2016-02-23" "2016-02-24"
##  [56] "2016-02-25" "2016-02-26" "2016-02-27" "2016-02-28" "2016-02-29"
##  [61] "2016-03-01" "2016-03-02" "2016-03-03" "2016-03-04" "2016-03-05"
##  [66] "2016-03-06" "2016-03-07" "2016-03-08" "2016-03-09" "2016-03-10"
##  [71] "2016-03-11" "2016-03-12" "2016-03-13" "2016-03-14" "2016-03-15"
##  [76] "2016-03-16" "2016-03-17" "2016-03-18" "2016-03-19" "2016-03-20"
##  [81] "2016-03-21" "2016-03-22" "2016-03-23" "2016-03-24" "2016-03-25"
##  [86] "2016-03-26" "2016-03-27" "2016-03-28" "2016-03-29" "2016-03-30"
##  [91] "2016-03-31" "2016-04-01" "2016-04-02" "2016-04-03" "2016-04-04"
##  [96] "2016-04-05" "2016-04-06" "2016-04-07" "2016-04-08" "2016-04-09"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{as.POSIXlt}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

Ahora, dado que \texttt{x} es una lista, puede usar el operador
\texttt{\$} para acceder a la información en días laborables y, por
supuesto, descubre que están separados por 7 días, a partir del 4 de
enero de 2016:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[x}\OperatorTok{$}\NormalTok{wday}\OperatorTok{==}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2016-01-04 UTC" "2016-01-11 UTC" "2016-01-18 UTC" "2016-01-25 UTC"
##  [5] "2016-02-01 UTC" "2016-02-08 UTC" "2016-02-15 UTC" "2016-02-22 UTC"
##  [9] "2016-02-29 UTC" "2016-03-07 UTC" "2016-03-14 UTC" "2016-03-21 UTC"
## [13] "2016-03-28 UTC" "2016-04-04 UTC"
\end{verbatim}

Suponga que desea enumerar las fechas del primer lunes de cada mes. Esta
es la fecha con \texttt{wday\ ==\ 1} (como arriba) pero solo en su
primera aparición en cada mes del año. Esto es un poco más complicado,
porque varios meses contendrán cinco lunes, por lo que no puede usar
\texttt{seq} con \texttt{by\ =\ "28\ days"} para resolver el problema
(esto generaría 13 fechas, no las 12 requeridas). Aquí están las fechas
de todos los lunes del año 2016:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{as.POSIXlt}\NormalTok{(}\KeywordTok{as.Date}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{365}\NormalTok{,}\DataTypeTok{origin=}\StringTok{"2015-12-31"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Esto es lo que sabemos hasta ahora:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{monday=}\NormalTok{y[y}\OperatorTok{$}\NormalTok{wday}\OperatorTok{==}\DecValTok{1}\NormalTok{],}\DataTypeTok{month=}\NormalTok{y}\OperatorTok{$}\NormalTok{mo[y}\OperatorTok{$}\NormalTok{wday}\OperatorTok{==}\DecValTok{1}\NormalTok{])[}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        monday month
## 1  2016-01-04     0
## 2  2016-01-11     0
## 3  2016-01-18     0
## 4  2016-01-25     0
## 5  2016-02-01     1
## 6  2016-02-08     1
## 7  2016-02-15     1
## 8  2016-02-22     1
## 9  2016-02-29     1
## 10 2016-03-07     2
## 11 2016-03-14     2
## 12 2016-03-21     2
\end{verbatim}

Desea que un vector marque los 12 lunes que necesita: estos son aquellos
en los que el mes no está duplicado (es decir, desea tomar la primera
fila de cada mes). Para este ejemplo, el primer lunes de enero está en
la fila 1 (obviamente), el primero en febrero en la fila 5, el primero
en marzo en la fila 10, y así sucesivamente. ¡Puede usar la función no
duplicada! Duplicada para etiquetar estas filas

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wanted <-}\StringTok{ }\OperatorTok{!}\KeywordTok{duplicated}\NormalTok{(y}\OperatorTok{$}\NormalTok{mo[y}\OperatorTok{$}\NormalTok{wday}\OperatorTok{==}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Por último, seleccione las 12 fechas de los primeros lunes usando quería
como subíndice como este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[y}\OperatorTok{$}\NormalTok{wday}\OperatorTok{==}\DecValTok{1}\NormalTok{][wanted]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "2016-01-04 UTC" "2016-02-01 UTC" "2016-03-07 UTC" "2016-04-04 UTC"
##  [5] "2016-05-02 UTC" "2016-06-06 UTC" "2016-07-04 UTC" "2016-08-01 UTC"
##  [9] "2016-09-05 UTC" "2016-10-03 UTC" "2016-11-07 UTC" "2016-12-05 UTC"
\end{verbatim}

Tenga en cuenta que cada mes está representado, y ninguna de las fechas
es posterior al 7 del mes, según sea necesario.

\subsection{Cálculo de diferencias entre las filas de un
dataframe}\label{cuxe1lculo-de-diferencias-entre-las-filas-de-un-dataframe}

Una acción común con datos de tiempo es calcular la diferencia de tiempo
entre filas sucesivas de un dataframe. El vector llamado duracion creado
anteriormente es de clase \texttt{difftime} y contiene 16 veces medido
en horas decimales:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(duracion)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "difftime"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{duracion}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time differences in hours
##  [1] 2.385000 3.271389 3.048889 2.750000 3.078333 2.940278 3.207778 1.953333
##  [9] 2.372778 1.701944 2.521389 3.254444 2.467778 1.926111 2.285278 1.813333
\end{verbatim}

Puede calcular las diferencias entre filas sucesivas utilizando
subíndices, como este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{duracion[}\DecValTok{1}\OperatorTok{:}\DecValTok{15}\NormalTok{]}\OperatorTok{-}\NormalTok{duracion[}\DecValTok{2}\OperatorTok{:}\DecValTok{16}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time differences in hours
##  [1] -0.8863889  0.2225000  0.2988889 -0.3283333  0.1380556 -0.2675000
##  [7]  1.2544444 -0.4194444  0.6708333 -0.8194444 -0.7330556  0.7866667
## [13]  0.5416667 -0.3591667  0.4719444
\end{verbatim}

\end{document}
